//* 1. TODO: Defini√°ld a Person t√≠pust (name: string, age: number)
type Person = {
    name: string;
    age: number;
};

const john: Person = {
    name: "John",
    age: 30,
};
//* 2. TODO: K√©sz√≠ts egy union t√≠pust, ami csak ezeket engedi: "admin", "user", "guest"
type Role = "admin" | "user" | "guest";

const role: Role = "admin"; // csak "admin", "user", vagy "guest" legyen enged√©lyezett
const role2: Role = "user";
const role3: Role = "guest";
// const role4: Role = "puppy"; // Hib√°t dob

//* 3. TODO: T√≠pus, amely egy objektumot √≠r le, aminek minden √©rt√©ke boolean
type Flags = {
    isActive: boolean;
    isVerified: boolean;
};

const flags: Flags = {
    isActive: true,
    isVerified: false,
};

//* 4. TODO: Generikus t√≠pus, ami becsomagolja az adott t√≠pust egy Promise-ba

type Async<T> = Promise<T>;

const fetchName = (): Async<string> => {
    return new Promise((resolve) => resolve("Eszti üíñ"));
};

//* 5. TODO: Defini√°lj egy Tuple t√≠pust, amely egy stringet √©s egy sz√°mot tartalmaz
type NameAndAge = [string, number];

const pair: NameAndAge = ["Eszti", 32];
//const pair1: NameAndAge = [32, "Eszti"]; // Hib√°t dob
//const pair1: NameAndAge = ["Eszti", "32"]; // Hib√°t dob
//const pair1: NameAndAge = [32, 32]; // Hib√°t dob
//* 6. TODO: Mapped type, ami minden mez≈ët opcion√°liss√° tesz
type Optional<T> = {
    [K in keyof T]?: T[K];
}

type User1 = {
    id: number;
    email: string;
};

type OptionalUser = Optional<User1>;

const maybeUser: OptionalUser = {
    // ak√°r √ºres objektum is lehet
};

//* 7. TODO: Conditional type ‚Äì ha T string, akkor legyen "text", k√ºl√∂nben "other"
type Describe<T> = T extends string ? "text" : "other";

type A = Describe<string>; // "text"
type B = Describe<number>; // "other"

//* 8. TODO: Discriminated union ‚Äì k√ºl√∂nb√∂z≈ë alakzatok t√≠pusa
type Shape1 = {
    kind: "circle" | "square";
    radius?: number | string;
    side?: number | string;
}

const circle: Shape1 = {
    kind: "circle",
    radius: 5
};

const square: Shape1 = {
    kind: "square",
    side: 10
};

//* 9. TODO: Type alias haszn√°lata readonly t√∂mbh√∂z
type ReadonlyNames = [string, string];

const names: ReadonlyNames = ["Eszti", "Lili"];
// names.push("valaki"); // hib√°t kell dobjon!

//* 10. TODO: Utility type - haszn√°lj Pick-et, hogy csak a 'name' √©s 'email' mez≈ë maradjon meg a User t√≠pusb√≥l
type UserPreview = {
    name: string
    age: number
    email: string
    address: string
    phone: string
}

const preview: Pick<UserPreview, 'name' & 'email'> = {
    name: "Elena",
    email: "elena@example.com"
};

//* 11. T√≠pusdefini√°l√°s
// TODO: Eg√©sz√≠tsd ki a User t√≠pust, hogy tartalmazzon: id (number), name (string), email (string), isActive (boolean)
type User = {
    id: number
    name: string
    email: string
    isActive: boolean
};

//* 12. Oszt√°ly √©s interf√©sz
// TODO: Hozz l√©tre egy Shape interf√©szt, benne area(): number met√≥dussal
interface Shape {
    area(): number
}

//* 13 TODO: K√©sz√≠ts egy Rectangle oszt√°lyt, amely implement√°lja a Shape interf√©szt, √©s kisz√°molja a ter√ºletet (width * height)
class Rectangle implements Shape {
    width: number;
    height: number;

    constructor(width: number, height: number) {
        this.width = width;
        this.height = height;
    }
    area(): number {
        return this.width * this.height;
    }
}

const rect = new Rectangle(10, 5);
console.log("T√©glalap ter√ºlete:", rect.area()); // Elv√°rt: 50

//* 14. Generikus f√ºggv√©ny
// TODO: K√©sz√≠ts egy generikus f√ºggv√©nyt wrapInArray n√©ven, amely b√°rmilyen t√≠pust t√∂mbb√© alak√≠t
function wrapInArray<T>(value: T): T[] {
    return [value];
}

console.log(wrapInArray("hello")); // Elv√°rt: ["hello"]

//* 15. Optional √©s readonly mez≈ëk
// TODO: Eg√©sz√≠tsd ki a Product interf√©szt: id (readonly number), name (string), description (opcion√°lis string), price (number)
interface Product {
    readonly id: number;
    name: string;
    description?: string;
    price: number;

}

// TODO: Hozz l√©tre egy p√©ld√°nyt a Product t√≠pus alapj√°n

const product: Product = {
    id: 1,
    name: "Laptop",
    description: "Very good Laptop",
    price: 100
};

// product.id = 2; // Ez hib√°t kell dobjon, mert readonly

//* 16. Hibakezel√©s
// TODO: √çrj egy divide f√ºggv√©nyt, amely a / b oszt√°st v√©gzi, de ha b = 0, akkor hib√°t dob
function divide(a: number, b: number): number {
    if (b === 0) {
        throw new Error("Null√°val nem osztunk!")
    } else {
        return a / b;
    }
}

console.log(divide(8, 2)); // Elv√°rt: 4
// console.log(divide(8, 0)); // Hib√°t dob



//? 17. Mapped type: ReadonlyDeep
// TODO: K√©sz√≠ts egy ReadonlyDeep mapped t√≠pust, amely rekurz√≠van readonly minden mez≈ët
type ReadonlyDeep<T> = {
    [P in keyof T]: T[P];
};

type Config = {
    server: {
        host: string;
        port: number;
    };
};

const config: ReadonlyDeep<Config> = {
    server: {
        host: "localhost",
        port: 8080
    }
};

// config.server.port = 9090; // Ez hib√°t kell dobjon
