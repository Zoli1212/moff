// 1. TODO: Defini√°ld a Person t√≠pust (name: string, age: number)
type PersonNew1 = {
    name: string
    age: number
};

const john: PersonNew1 = {
    name: "John",
    age: 30,
};

// 2. TODO: K√©sz√≠ts egy union t√≠pust, ami csak ezeket engedi: "admin", "user", "guest"
type Role = "admin" | "user" | "guest";
// csak "admin", "user", vagy "guest" legyen enged√©lyezett
const role: Role = "admin"; 
const role2: Role = "user";
const role3: Role = "guest";

// 3. TODO: T√≠pus, amely egy objektumot √≠r le, aminek minden √©rt√©ke boolean
type Flags = {
    isActive: boolean, 
    isVerified: boolean,
    isUser: boolean,
    isAdmin: boolean
};

const flags: Flags = {
    isActive: true,
    isVerified: false,
    isUser: false,
    isAdmin: true
};

// 4. TODO: Generikus t√≠pus, ami becsomagolja az adott t√≠pust egy Promise-ba
// type Async<T> T : Promise<T> = {
//     return T
// }

// const fetchName = (): Async<string> => {
//   return new Promise((resolve) => resolve("Eszti üíñ"));
// };

// 5. TODO: Defini√°lj egy Tuple t√≠pust, amely egy stringet √©s egy sz√°mot tartalmaz
type NameAndAge = (string | number)[]

const pairNew: NameAndAge = ["Eszti", 32];

// 6. TODO: Mapped type, ami minden mez≈ët opcion√°liss√° tesz
type OptionalNew<T> = {
    [K in keyof T] ?: T[K]
};

type UserNew = {
  id: number;
  email: string;
};

type OptionalUser = Optional<UserNew>;

const maybeUser: OptionalUser = {
  // ak√°r √ºres objektum is lehet
};

// 7. TODO: Conditional type ‚Äì ha T string, akkor legyen "text", k√ºl√∂nben "other"
// type Describe<T> = T extends string

// type A = Describe<string>; // "text"
// type B = Describe<number>; // "other"

// 8. TODO: Discriminated union ‚Äì k√ºl√∂nb√∂z≈ë alakzatok t√≠pusa
type ShapeNew = {kind: "circle"; radius: number} | {kind: "square"; side: number};

const circle: ShapeNew = {
    kind: "circle",
    radius: 5
};

const square: ShapeNew = {
    kind: "square",
    side: 10
};

// 9. TODO: Type alias haszn√°lata readonly t√∂mbh√∂z
type ReadonlyNames<T> = ReadonlyArray<T>;

const names: ReadonlyNames<string> = ["Eszti", "Lili"];
names.push("valaki"); // hib√°t kell dobjon!

// 10. TODO: Utility type - haszn√°lj Pick-et, hogy csak a 'name' √©s 'email' mez≈ë maradjon meg a User t√≠pusb√≥l
type UserType = {
    name: string,
    password: string,
    age: number,
    email: string
}

type UserPreview = Pick<UserType, "name" | "email">;

const preview: UserPreview = {
    name: "Elena",
    email: "elena@example.com"
};

// 11. T√≠pusdefini√°l√°s
// TODO: Eg√©sz√≠tsd ki a User t√≠pust, hogy tartalmazzon: id (number), name (string), email (string), isActive (boolean)
type UserNew11 = {
    id: number,
    name: string,
    email: string, 
    isActive: boolean
};

// 12. Oszt√°ly √©s interf√©sz
// TODO: Hozz l√©tre egy Shape interf√©szt, benne area(): number met√≥dussal
interface ShapeNew12 {
    area(): number;
}

// 13 TODO: K√©sz√≠ts egy Rectangle oszt√°lyt, amely implement√°lja a Shape interf√©szt, √©s kisz√°molja a ter√ºletet (width * height)
class Rectangle12 implements ShapeNew12 {
    constructor(public width: number, public height: number){}
    area(): number {
        return this.width * this.height;
    }
}

const rect = new Rectangle12(10, 5);
console.log("T√©glalap ter√ºlete:", rect.area()); // Elv√°rt: 50

// 14. Generikus f√ºggv√©ny
// TODO: K√©sz√≠ts egy generikus f√ºggv√©nyt wrapInArray n√©ven, amely b√°rmilyen t√≠pust t√∂mbb√© alak√≠t
function wrapInArray<T>(value: T): T[] {
    return ([] as T[]).concat(value);
}

console.log(wrapInArray("hello")); // Elv√°rt: ["hello"]

// 15. Optional √©s readonly mez≈ëk
// TODO: Eg√©sz√≠tsd ki a Product interf√©szt: id (readonly number), name (string), description (opcion√°lis string), price (number)
interface Product15 {
    readonly id: number,
    name: string,
    description?: string,
    price: number
}

// TODO: Hozz l√©tre egy p√©ld√°nyt a Product t√≠pus alapj√°n

const product15: Product15 = {
    id: 1,
    name: "laptop",
    description: "something",
    price: 15
};

product15.id = 2; // Ez hib√°t kell dobjon, mert readonly

// 16. Hibakezel√©s
// TODO: √çrj egy divide f√ºggv√©nyt, amely a / b oszt√°st v√©gzi, de ha b = 0, akkor hib√°t dob
function divide(a: number, b: number): number {
    if (b === 0) {
        throw new Error("Error");
    } else {
        return a / b;
    }
}

console.log(divide(8, 2)); // Elv√°rt: 4

// 17. Mapped type: ReadonlyDeep
// TODO: K√©sz√≠ts egy ReadonlyDeep mapped t√≠pust, amely rekurz√≠van readonly minden mez≈ët
type ReadonlyDeep<T> = {
    readonly [C in keyof T]: ReadonlyDeep<T[C]>
};

type Config17 = {
    server: {
        host: string;
        port: number;
    };
};

const config: ReadonlyDeep<Config> = {
  server: {
    host: "localhost",
    port: 8080
  }
};

config.server.port = 9090; // Ez hib√°t kell dobjon