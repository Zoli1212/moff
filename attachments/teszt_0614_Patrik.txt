// hatarido 15:30

// 1. 
// TODO: Defini√°ld a Person t√≠pust (name: string, age: number)
type Person1 = {
    name: string,
    age: number
};

const john: Person1 = {
    name: "John",
    age: 30,
};



// 2. 
// TODO: K√©sz√≠ts egy union t√≠pust, ami csak ezeket engedi: "admin", "user", "guest"
type Role1 = "admin" | "user" | "guest"


const role: Role1 = "admin"; // csak "admin", "user", vagy "guest" legyen enged√©lyezett



// 3. 
// TODO: T√≠pus, amely egy objektumot √≠r le, aminek minden √©rt√©ke boolean
type Flags1 = {
    // p√©ld√°ul: isActive: true, isVerified: false, ...
    isActive: boolean,
    isVerified: boolean,
    isDisable?: boolean,
    isUsed?: boolean,
    isHiden?: boolean
};

const flags: Flags1 = {
    isActive: true,
    isVerified: false,
};





// 4. 
// TODO: Generikus t√≠pus, ami becsomagolja az adott t√≠pust egy Promise-ba
type Async<T> = Promise<T>


const fetchName = (): Async<string> => {
    return new Promise((resolve) => resolve("Eszti üíñ"));
};



// 5. 
// TODO: Defini√°lj egy Tuple t√≠pust, amely egy stringet √©s egy sz√°mot tartalmaz
type NameAndAge = [name: string, age: number]

const pair1: NameAndAge = ["Eszti", 32];



// 6. 
// TODO: Mapped type, ami minden mez≈ët opcion√°liss√° tesz
type Optional1<T> = {
    [ID in keyof T]?: T[ID]
};

type User11 = {
    id: number;
    email: string;
    test: string;
};

type OptionalUser = Optional1<User11>;

const maybeUser: OptionalUser = {
    id: 1233,
    test: "valami szoveg.."
};



// 7. 
// TODO: Conditional type ‚Äì ha T string, akkor legyen "text", k√ºl√∂nben "other"

// HIBA! type Describe<T> = typeof T === "string" ? "text" : "other"
type Describe<T> = T extends string ? "text" : "other"
// ...

type A31 = Describe<string>; // "text"

type B31 = Describe<number>; // "other"

type B32 = Describe<"Hello">



// 8. 
// TODO: Discriminated union ‚Äì k√ºl√∂nb√∂z≈ë alakzatok t√≠pusa
type Shapee =

    | { kind: "circle", radius: number }
    | { kind: "square", radius: number }
    | { kind: "square", side: number }

const circle: Shapee = {
    kind: "circle",
    radius: 5
};

const square: Shapee = {
    kind: "square",
    side: 10
};



// 9. 
// TODO: Type alias haszn√°lata readonly t√∂mbh√∂z
type ReadonlyNames = readonly string[]
type ReadonlyNums = readonly number[]

const names: ReadonlyNames = ["Eszti", "Lili"];
const numberss: ReadonlyNums = [1, 2, 3, 73, 4];
// names.push("valaki"); // hib√°t kell dobjon!



// 10. 
// TODO: Utility type - haszn√°lj Pick-et, hogy csak a 'name' √©s 'email' mez≈ë maradjon meg a User t√≠pusb√≥l
type User21 = {
    name: string,
    email: string
    age: number,
}

const xa: User21 = { name: "Peter", email: "email@email.cc", age: 30 }

type UserPreview = Pick<User21, "name" | "email">

const preview: UserPreview = {
    name: "Elena",
    email: "elena@example.com"
};

// 11. T√≠pusdefini√°l√°s
// TODO: Eg√©sz√≠tsd ki a User t√≠pust, hogy tartalmazzon: id (number), name (string), email (string), isActive (boolean)
type Userr = {
    id: number
    name: string
    email: string
    isActive: boolean
};



// 12. Oszt√°ly √©s interf√©sz
// TODO: Hozz l√©tre egy Shape interf√©szt, benne area(): number met√≥dussal
interface Shape1 {

    area(): number
}

// 13 TODO: K√©sz√≠ts egy Rectangle oszt√°lyt, amely implement√°lja a Shape interf√©szt, √©s kisz√°molja a ter√ºletet (width * height)
class Rectangle implements Shape1 {
    constructor(public height: number, public width: number) { }

    area(): number {
        return this.width * this.height
    }

}

const rect = new Rectangle(10, 5);
console.log("T√©glalap ter√ºlete:", rect.area()); // Elv√°rt: 50

// 14. Generikus f√ºggv√©ny
// TODO: K√©sz√≠ts egy generikus f√ºggv√©nyt wrapInArray n√©ven, amely b√°rmilyen t√≠pust t√∂mbb√© alak√≠t
function wrapInArray<T>(value: T): T[] {
    return [value]
}

console.log(wrapInArray("hello")); // Elv√°rt: ["hello"]

// 15. Optional √©s readonly mez≈ëk
// TODO: Eg√©sz√≠tsd ki a Product interf√©szt: id (readonly number), name (string), description (opcion√°lis string), price (number)
interface Product51 {

    readonly id: number,
    name: string,
    description?: string,
    price: number,
}

// TODO: Hozz l√©tre egy p√©ld√°nyt a Product t√≠pus alapj√°n

const product: Product51 = {
    id: 1523,
    name: "Laptop",
    price: 150000
};

// product.id = 2; // Ez hib√°t kell dobjon, mert readonly

// 16. Hibakezel√©s
// TODO: √çrj egy divide f√ºggv√©nyt, amely a / b oszt√°st v√©gzi, de ha b = 0, akkor hib√°t dob
function divide(a: number, b: number): number {
    if (b == 0) {
        throw new Error("[HIBA] - Null√°val nem lehet osztani!")
    } else {
        return a / b
    }
}

console.log(divide(8, 2)); // Elv√°rt: 4

// 17. Mapped type: ReadonlyDeep
// TODO: K√©sz√≠ts egy ReadonlyDeep mapped t√≠pust, amely rekurz√≠van readonly minden mez≈ët
type ReadonlyDeep<T> = {
    readonly [ID in keyof T]: T[ID]
};

type Configg = {
    server: {
        host: string;
        port: number;
    };
};

const config: ReadonlyDeep<Configg> = {
    server: {
        host: "localhost",
        port: 8080
    }
};

// config.server.port = 9090; // Ez hib√°t kell dobjon


